\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage{graphicx}
\usepackage[justification=centering,labelfont=bf]{caption}
\usepackage{listings}
\usepackage{minted}
\usepackage[hidelinks]{hyperref}
\begin{document}
\begin{titlepage}
\begin{center}
\textsc{\Large Parallelism}
\\
\texttt{1202}
\\[1.5cm]
\rule{\linewidth}{0.5mm}
\\[0.4cm]
{\huge
\bfseries
Lab 3: Divide and conquer parallelism with OpenMP - Sorting
\\[0.4cm]
}
\rule{\linewidth}{0.5mm}
\\[2.5cm]
\begin{minipage}{0.4\textwidth}
\begin{flushleft}
\large
Héctor Ramón Jiménez
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright}
\large
Alvaro Espuña Buxo
\end{flushright}
\end{minipage}
\vfill
{\large
\today
}
\\
{\large
\texttt{Facultat d'Informàtica de Barcelona}
}
\end{center}
\end{titlepage}
\section{Analysis with Tareador}
\begin{enumerate}
\setcounter{enumi}{0}
\item
\textbf{Include the source of the sequential multisort.c code modified
  with the calls to the Tareador API and the task graph generated.}

\item
  \textbf{Write a table with the execution time and speed-up predicted
    by Dimemas (for 1, 2, 4, 8, 16, 32 and 64 processors) for the task
    decomposition specified with Tareador. Are the results close to the
    ideal case? Reason about your answer.}
\end{enumerate}

\section{Parallelization with OpenMP}
\begin{enumerate}
  \setcounter{enumi}{2}
  \item
    \textbf{ Briefly describe the two versions (Leaf and Tree)
      implemented, making references to the source code included in
      the compressed tar file.}
\end{enumerate}
\section{Performance analysis}
\textbf{Write a text, inspired in the one provided below, summarizing
  the performance results for the two versions (Leaf and Tree) of
  multisort.}

The performance of the two parallelization strategies for multisort
has been analyzed on a multiprocessor architecture with 12 Intel
cores ... /* complete this paragraph with the information you got in
the first laboratory assignment */.  For all the performance results we
have used an input vector of size XXX randomly generated by the
program itself. The program performs several sort steps in order to
verify the influence of the randomness of the data in the input
vector. The recursive depth of the multisort algorithm is controlled
with /* complete this paragraph with the appropriate information */
The first conclusion of the analysis is that version XXX has better
scalability than version YYY. This is due to the fact that the
parallelism exploited in version YYY is limited by /* complete the
paragraph with an appropriate reasoning */. Figure 1 shows the
execution timelines visualized with Paraver, supporting the previous
argument.  Figure 2 plots the speedup, with respect to the sequential,
for different vector sizes (8, 16 and 32 Megaelements), for the two
OpenMP versions and for the different invocations of multisort in the
main program.

\end{document}
